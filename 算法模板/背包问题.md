 # 背包问题

 ## 1. 01背包问题

有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci ，得到的价值是 Wi 。求解将哪些物品装入背包可使价值总和最大，输出最大价值。

### 基本思路

F[i,v] 表示前 i 件物品放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程为：
```java
F[i, v] = max{f[i - 1, v], f[i - 1, v - Ci] + Wi} //要么不放，要么放
```

伪代码如下：
```java
F[0, 0...V] ← 0
for i ← 1 to N
    for v ← Ci to V
        F[i,v] ← max{F[i − 1,v],F[i − 1,v − Ci] + Wi}
```

### 优化空间复杂度

在每次主循环中我们以 v ← V...Ci 的递减顺序计算 F[v] ，这样才能保证计算 F[v] 时 F[v − Ci] 保存的是状态 F[i − 1,v − Ci] 的值。伪代码如下：
```java
F[0...V] ← 0
for i ← 1 to N
    for v ← V to Ci
        F[v] ← max{F[v], F[v − Ci] + Wi}
```

将处理一件 01 背包中的物品过程抽象化：
```java
def ZeroOnePack(F, C, W)
    for v ← V to C
        F[v] ← max(F[v], F[v − C] + W)
```
现在 01 背包的伪代码就可以改为：
```java
F[0...V] ← 0
for i ← 1 to N
    ZeroOnePack(F, Ci, Wi)
```

### 初始化的细节

* 如果要求恰好装满背包，那么在初始化时除了 F[0] 为 0 ，其它F[1...V] 均设为 −∞ ，这时候求最大收益需要遍历F[1...V]找最大值。

* 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F[0...V]全部设为 0 ，这时候求最大收益就是F[V]。

解释：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为 0了。


## 2. 完全背包问题

有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci ，价值是 Wi 。求解将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。

### 基本思路

按照解 01 背包时的思路，令 F[i, v] 表示前 i 种物品放入一个容量为 v 的背包的最大价值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：
```java
F[i, v] = max{F[i − 1, v − k * Ci] + k * Wi} (0 ≤ k * Ci ≤ v)
```
事实上这也是解多重背包的基本思路。

### 优化

```java
F[0...V] ← 0
for i ← 1 to N
    for v ← Ci to V
        F[v] ← max(F[v], F[v − Ci] + Wi)
```
在每次主循环中我们以 v ← Ci...V 的递增顺序计算 F[v]，可以抽象理解为计算F[v]时，借助的是F[i][v-Ci]，此时可能第 i 个物品已经被选入，就没有所谓的一件限制了。

抽象出处理一件完全背包类物品的过程伪代码：
```java
def CompletePack(F, C, W)
    for v ← C to V
        F[v] ← max{F[v], f[v − C] + W}
```

## 3. 多重背包问题

有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci ，价值是 Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。

### 基本思路

对于第 i 种物品有 Mi + 1 种策略：取 0 件，取 1 件……取 M i 件。令 F[i,v] 表示前 i 种物品放入一个容量为 v 的背包的最大价值，则有状态转移方程：
```java
F[i, v] = max{F[i − 1, v − k ∗ Ci] + k ∗ Wi} (0 ≤ k ≤ Mi)
```

### 二进制分解转化为01背包

将第 i 种物品分成若干件 01 背包中的物品，其中每件物品有一个系数。这件物品的费用和价值均是原来的费用和价值乘以这个系数。令这些系数分别为1，2，2^2 ... 2^(k−1)，Mi − 2^k + 1，且 k 是满足 Mi − 2^k + 1 > 0 的最大整数。

抽象化处理一件多重背包中物品的过程如下：
```java
def MultiplePack(F, C, W, M)
if C · M ≥ V
    CompletePack(F, C, W)
    return
k ← 1
while k < M
    ZeroOnePack(k*C, k*W)
    M ← M − k
    k ← 2k
ZeroOnePack(C · M,W · M)
```

## 4. 混合背包问题

如果将前面的三种背包问题混合起来。也就是说，有的物品只可以取一次（ 01 背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？

### 基本思路

分类求解即可。

```java
for i ← 1 to N
    if 第 i 件物品属于 01 背包
        ZeroOnePack(F, Ci, Wi)
    else if 第 i 件物品属于完全背包
        CompletePack(F, Ci, Wi)
    else if 第 i 件物品属于多重背包
        MultiplePack(F, Ci, Wi, Mi)
```

## 5. 二维费用的背包问题

二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。
设第 i 件物品所需的两种费用分别为 Ci 和 Di 。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U 。物品的价值为 Wi 。

### 基本思路

费用加了一维，只需状态也加一维即可。设 F[i,v,u] 表示前 i 件物品付出两种费用分别为 v 和 u 时可获得的最大价值。状态转移方程就是：
```java
F[i, v, u] = max{F[i − 1, v, u], F[i − 1,v − Ci ,u − Di] + Wi}
```
如前述优化空间复杂度的方法，可以只使用二维的数组。当每件物品只可以取一次时,变量 v 和 u 采用逆序的循环，当物品有如完全背包问题时采用顺序的循环，当物品有如多重背包问题时拆分物品。

## 6. 分组背包问题

有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci ，价值是 Wi 。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 基本思路

每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设 F[k,v] 表示前 k 组物品花费费用 v 能取得的最大价值，则有：
```java
F[k,v] = max{F[k − 1,v],F[k − 1,v − Ci] + Wi} (item i ∈ group k)
```
使用一维数组的伪代码如下：
```java
for k ← 1 to K
    for v ← V to 0
        for all item i in group k
            F[v] ← max{F[v], F[v − Ci] + Wi}
```
这里三层循环的顺序保证了每一组内的物品最多只有一个会被添加到背包中。

## 7. 背包问题的方案

### 输出方案
要求输出这个最优值的方案。

一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的。
以 01 背包为例，方程为
```java
F[i, v] = max{F[i − 1, v], F[i − 1, v − Ci] + Wi} 
```
再用一个数组 G[i,v] ，设 G[i,v] = 0 表示推出 F[i,v] 的值时是采用了方程的前一项，G[i,v] = 1 表示采用了方程的后一项。注意这两项分别表示了两
种策略：未选第 i 个物品及选了第 i 个物品。那么输出方案的伪代码可以这样写：
```java
i ← N
v ← V
while i > 0
    if G[i,v] = 0
        print 未选第 i 项物品
    else if G[i,v] = 1
        print 选了第 i 项物品
        v ← v − Ci
    i ← i − 1
```
另外，采用方程的前一项或后一项也可以在输出方案的过程中根据 F[i,v] 的值实时地求出来。不须纪录 G 数组，将上述代码中的 G[i,v] = 0 改成 F[i,v] = F[i − 1,v] ，G[i,v] = 1 改成 F[i,v] = F[i − 1][v − Ci] + Wi 也可。

### 求方案总数

求装满背包或将背包装至某一指定容量的方案总数。

对于这类改变问法的问题，一般只需将状态转移方程中的 max 改成 sum 即可。例如若每件物品均是完全背包中的物品，转移方程即为
```java
F[i, v] = sum{F[i − 1, v], F[i, v − Ci]}
```
初始条件是 F[0, 0] = 1 。

### 最优方案的总数

这里的最优方案是指物品总价值最大的方案。以 01 背包为例。结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：

F[i,v] 代表该状态的最大价值， G[i,v] 表示这个子问题的最优方案的总数，则在求F[i,v] 的同时求 G[i,v] 的伪代码如下：
```java
G[0, 0] ← 1
for i ← 1 to N
    for v ← 0 to V
        F[i,v] ← max{F[i − 1,v],F[i − 1,v − Ci ] + Wi}
        G[i,v] ← 0
        if F[i,v] = F[i − 1,v]
            G[i,v] ← G[i,v] + G[i − 1][v]
        if F[i,v] = F[i − 1,v − Ci] + Wi
            G[i,v] ← G[i,v] + G[i − 1][v − Ci]
```